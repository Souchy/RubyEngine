/*
 * This source file was generated by the Gradle 'init' task
 */

#include "RubyEngine.h"
#include <iostream>
#include <util/shapes/Cube.h>

std::string RubyEngine::Greeter::greeting() {
    new Node3d();
    return std::string("Hello, World!");
}

void Ruby::start() {
    
    // ---------- Systems
    
    world.system<Window>("Inputs").term_at(0).singleton().kind(flecs::PreUpdate) //
        .each([](flecs::iter &it, size_t i, Window &w) {
            if (glfwGetKey(w.m_window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
                glfwSetWindowShouldClose(w.m_window, true);
            // if (!m_imGuiActive)
            // {
            // 	m_camera.keybordEvents(m_window, delta_time);
            // }
        });
    world.system<Transform3d, Velocity>("Update").kind(flecs::OnUpdate) //
        .each([](flecs::iter &it, size_t i, Transform3d &trans, const Velocity &vel) {
            auto mat = glm::translate(trans.value, vel.value * it.delta_time());
            trans.value = mat;
        });
    world.system<Transform3d, Mesh, Material>("Render").kind(flecs::OnUpdate) //
        .each([](flecs::iter &it, size_t i, const Transform3d &trans, const Mesh &mesh, const Material &mat) {
            auto e = it.entity(i);
            // render cubes
            glm::mat4 worldTransform = Ruby::computeWorldTransform(e);

            // std::printf("Draw {%s} at {%f}\n", e.name(), worldTransform[0][1]);
            std::cout << "Draw: " << e.name() << std::endl;

            // RenderScene(delta_time);
            // RenderImgui();
        });
    world.system<Window>("Window").term_at(0).singleton().kind(flecs::PostUpdate) //
        .each([](flecs::iter &it, size_t i, Window &w) {
            // Show rendering and get events
            glfwSwapBuffers(w.m_window);
            // m_imGuiActive = ImGui::IsAnyItemActive();
            glfwPollEvents();
        });


    // ---------- Entities
    
    Mesh *cube = Cube::generate();
    Material mat;

    Transform3d tr1;
    tr1.value = glm::translate(glm::mat4(1.0f), glm::vec3(1.0f));
    flecs::entity parent = this->world.entity("parent").add<Material>();
    parent.set<Transform3d>(tr1);
    parent.set<Mesh>(*cube);

    Transform3d tr2;
    tr2.value = glm::scale(tr1.value, glm::vec3(1.0f));
    flecs::entity child = this->world.entity("child").child_of(parent).add<Material>();
    child.set<Transform3d>(tr2);
    child.set<Mesh>(*cube);

    Transform3d tr3;
    tr3.value = glm::translate(tr2.value, glm::vec3(3.0f));
    flecs::entity grandchild = this->world.entity("grandchild").child_of(child).add<Material>();
    grandchild.set<Transform3d>(tr3);
    grandchild.set<Mesh>(*cube);

    Window window;
    if (window.initialize() != 0) {
        return;
    }
    world.set<Window>(window);

    // Shader* shader;
    // shader->addShaderFromSource();

	bool success = true;
	auto m_mainShader = std::make_unique<Shader>();
	success &= m_mainShader->addShaderFromSource(GL_VERTEX_SHADER, "shaders/basicShader.vert");
	//success &= m_mainShader->addShaderFromSource(GL_GEOMETRY_SHADER, directory + "shaders/basicShader.geo");
	success &= m_mainShader->addShaderFromSource(GL_FRAGMENT_SHADER, "shaders/basicShader.frag");
	success &= m_mainShader->link();
	if (!success)
	{
		std::cerr << "Error when loading main shader\n";
		return;
	}

    // ---------- Engine loop

    float time = (float)glfwGetTime();
    float delta_time = 1.0f / 60.0f;
    while (world.progress(delta_time)) {
        // Compute delta time between two frames
        float new_time = (float)glfwGetTime();
        delta_time = new_time - time;
        time = new_time;
    }
    
    // ---------- Cleanup
    glfwDestroyWindow(window.m_window);
    glfwTerminate();
}

glm::mat4 Ruby::computeWorldTransform(flecs::entity e) {
    glm::mat4 mat = e.get<Transform3d>()->value;
    auto parent = e.parent();
    if (parent && parent.has<Transform3d>()) {
        mat *= Ruby::computeWorldTransform(parent);
    }
    return mat;
}
